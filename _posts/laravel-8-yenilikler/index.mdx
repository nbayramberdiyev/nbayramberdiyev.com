---
title: Laravel 8 Yenilikler
date: 2020-09-12
tags: [laravel, php]
excerpt: Laravel 8'in pastÄ±rma tadÄ±ndaki yeni Ã¶zellikleri
---

2011 yÄ±lÄ±nda ilk versiyonuyla web development Ã¢lemine "merhaba" diyen Laravelâ€™in bu hafta (08.09.2020) itibariyle 8. versiyonu resmi olarak kullanÄ±ma sunuldu.

Yeniliklere baktÄ±ÄŸÄ±mÄ±zda breaking change olmamakla birlikte <a href="https://github.com/laravel/jetstream" target="_blank">Laravel Jetstream</a>, model factory sÄ±nÄ±flarÄ±, migration squashing, job batching, daha geliÅŸmiÅŸ rate limiting, queue iyileÅŸtirmeleri ve dinamik Blade component'leri gibi Ã¶zelliklerin tanÄ±tÄ±ldÄ±ÄŸÄ±nÄ± ve Laravel 7'deki geliÅŸtirmelere/iyileÅŸtirmelere devam edildiÄŸini gÃ¶rebiliriz. Developer deneyimini daha da ileri taÅŸÄ±yacak olan yeni Ã¶zellikleri aÅŸaÄŸÄ±da ele aldÄ±m:

-   [Laravel JetStream](#laravel-jetstream)
-   [Models KlasÃ¶rÃ¼](#models-klasÃ¶rÃ¼)
-   [Model Factory SÄ±nÄ±flarÄ±](#model-factory-sÄ±nÄ±flarÄ±)
-   [Migration Squashing](#migration-squashing)
-   [Job Batching](#job-batching)
-   [Rate Limiting GeliÅŸtirmeleri](#rate-limiting-geliÅŸtirmeleri)
-   [BakÄ±m Modu GeliÅŸtirmeleri](#bakÄ±m-modu-geliÅŸtirmeleri)
-   [Closure Dispatch / Chain `catch`](#closure-dispatch--chain-catch)
-   [Dinamik Blade Component'leri](#dinamik-blade-componentleri)
-   [Event Listener GeliÅŸtirmeleri](#event-listener-geliÅŸtirmeleri)
-   [Zaman Testi Ä°Ã§in Helper FonksiyonlarÄ±](#zaman-testi-iÌ‡Ã§in-helper-fonksiyonlarÄ±)
-   [Artisan serve GeliÅŸtirmeleri](#artisan-serve-geliÅŸtirmeleri)
-   [Tailwind Ä°le Pagination Linkleri](#tailwind-iÌ‡le-pagination-linkleri)
-   [Routing Namespace GÃ¼ncellemeleri](#routing-namespace-gÃ¼ncellemeleri)

## Laravel Jetstream

Hemen hemen her uygulamanÄ±n ihtiyaÃ§ duyabileceÄŸi kullanÄ±cÄ± giriÅŸi/kaydÄ±, e-posta doÄŸrulama, two-factor authentication (2FA), session yÃ¶netimi, API authentication gibi Ã¶zellikleri iÃ§inde barÄ±ndÄ±ran Laravel ekosisteminin yeni Ã¼rÃ¼nÃ¼ Laravel Jetstream, bir Laravel uygulamasÄ± iÃ§in baÅŸlangÄ±Ã§ ÅŸablonu (iskelesi) diyebiliriz.

Daha Ã¶nce, <a href="https://github.com/laravel/ui" target="_blank">`laravel/ui`</a> paketi uygulamamÄ±zda authentication iÅŸlemlerini otomatik olarak yapmamÄ±za imkÃ¢n saÄŸlÄ±yordu. Laravel Jetstream ise bu paketin daha geliÅŸmiÅŸ hali olarak dÃ¼ÅŸÃ¼nebiliriz. ArayÃ¼zÃ¼ <a href="https://tailwindcss.com" target="_blank">Tailwind CSS</a> ile geliÅŸtirilen Laravel JetStream, isteÄŸe baÄŸlÄ± olarak <a href="https://github.com/livewire/livewire" target="_blank">Livewire</a> veya <a href="https://github.com/inertiajs/inertia-laravel" target="_blank">Inertia</a> ile birlikte kullanÄ±labilir.

Laravel Jetstream web authentication iÅŸlemleri iÃ§in <a href="https://github.com/laravel/fortify" target="_blank">Laravel Fortify</a>, token bazlÄ± authentication (SPA, mobil uygulamalar) iÃ§in ise <a href="https://github.com/laravel/sanctum" target="_blank">Laravel Sanctum</a> kullanmakta.

Kurulum ve kullanÄ±mÄ±na ayrÄ± bir yazÄ±ya konu olacak nitelikte olduÄŸundan burada yer vermedim. DetaylÄ± bilgiler iÃ§in <a href="https://jetstream.laravel.com" target="_blank">dokÃ¼mantasyonuna</a> bakabilirsiniz.

![](./laravel-jetstream.png)

## Models KlasÃ¶rÃ¼

Laravel'in Ã¶nceki versiyonlarÄ±nda Eloquent model dosyalarÄ±nÄ±n varsayÄ±lan yeri `app` klasÃ¶rÃ¼ydÃ¼. Modellerin controller veya middleware dosyalarÄ±na benzer Ã¶zel bir klasÃ¶rÃ¼ yoktu. Bunun nedenini Laravel, <U>Models</U> kelimesinin farklÄ± geliÅŸtirciler iÃ§in farklÄ± anlamlara gelebileceÄŸinden kafalarda karÄ±ÅŸÄ±klÄ±k yaratmasÄ± ÅŸeklinde <a href="https://laravel.com/docs/7.x/structure#introduction" target="_blank">aÃ§Ä±klÄ±yor</a>. Ã–rneÄŸin, model bazÄ± geliÅŸtiriciler iÃ§in uygulamanÄ±n tÃ¼m business logicâ€™i anlamÄ±na gelirken bazÄ± geliÅŸtiriciler iÃ§inse (ben dahil) iliÅŸkisel veritabanÄ± ile ilgili iÅŸlemleri yapmamÄ±zÄ± saÄŸlayan sÄ±nÄ±f/obje anlamÄ±na gelmektedir.

Model dosyalarÄ±nÄ±n derli toplu olmasÄ± iÃ§in manuel olarak `app/Models` klasÃ¶rÃ¼ oluÅŸturuyorduk. TopluluÄŸun yoÄŸun talebi Ã¼zerine artÄ±k Eloquent model dosyalarÄ±mÄ±zÄ±n varsayÄ±lan yeri `app/Models` olacak. TÃ¼m Artisan komutlarÄ± da buna duyarlÄ± olacak. Yani eÄŸer projede `app/Models` klasÃ¶rÃ¼ varsa, framework onu model klasÃ¶rÃ¼ olarak varsayacak. Yoksa da, eskisi gibi `app` klasÃ¶rÃ¼nÃ¼ kullanmaya devam edecek. ğŸ‰

## Model Factory SÄ±nÄ±flarÄ±

Eskiden model factory'leri sÄ±nÄ±f tabanlÄ± deÄŸildi ve `factory` global fonksiyonu ile test verileri oluÅŸturabiliyorduk. Laravel 8'de bu fonksiyon kaldÄ±rÄ±ldÄ± ve factory'ler sÄ±nÄ±f tabanlÄ± olacak ÅŸekilde tamamiyle yeniden yazÄ±ldÄ±. ArtÄ±k her modelde `HasFactory` traiti olacak ve modellerin kendine ait factory sÄ±nÄ±flarÄ± olacak.

Ã–rneÄŸin, yeni Laravel projesi oluÅŸturduÄŸumuzda `database/factories` klasÃ¶rÃ¼ iÃ§inde `UserFactory.php` dosyasÄ± bulunuyor. Bu dosyanÄ±n iÃ§eriÄŸi eskiden ÅŸu ÅŸekildeydi:

```php:title=app/database/factories/UserFactory.php
<?php

/** @var \Illuminate\Database\Eloquent\Factory $factory */

use App\Models\User;
use Faker\Generator as Faker;
use Illuminate\Support\Str;

$factory->define(User::class, function (Faker $faker) {
    return [
        'name' => $faker->name,
        'email' => $faker->unique()->safeEmail,
        'email_verified_at' => now(),
        'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password
        'remember_token' => Str::random(10),
    ];
});
```

Ve ÅŸu ÅŸekilde kullanÄ±rdÄ±k:

```php
factory(App\Models\User::class, 10)->make(); // Test amaÃ§lÄ± 10 tane kullanÄ±cÄ± oluÅŸtur.
```

Bundan sonra factory'ler sÄ±nÄ±f tabanlÄ± olacak:

```php:title=app/database/factories/UserFactory.php
<?php

namespace Database\Factories;

use App\Models\User;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Support\Str;

class UserFactory extends Factory
{
    /**
     * The name of the factory's corresponding model.
     *
     * @var string
     */
    protected $model = User::class;

    /**
     * Define the model's default state.
     *
     * @return array
     */
    public function definition()
    {
        return [
            'name' => $this->faker->name,
            'email' => $this->faker->unique()->safeEmail,
            'email_verified_at' => now(),
            'password' => '$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password
            'remember_token' => Str::random(10),
        ];
    }
}
```

Ve ÅŸu ÅŸekilde kullanabileceÄŸiz:

```php
$users = App\Models\User::factory()->count(10)->make(); // Test amaÃ§lÄ± 10 tane kullanÄ±cÄ± oluÅŸtur.
```

Factory'ler sÄ±nÄ±f tabanlÄ± olacaÄŸÄ±ndan dolayÄ± iÃ§ine ihtiyaÃ§ duyduÄŸumuz metodlarÄ± yazabiliriz. YukarÄ±daki Ã¶rnek Ã¼zerinden gidecek olursak, kullanÄ±cÄ±larÄ±n `status` deÄŸerlerini tuttuÄŸumuzu ve `status` deÄŸerinin `active` olduÄŸu 10 tane kullanÄ±cÄ± oluÅŸturmak istediÄŸimizi varsayalÄ±m. Bunu yapmak iÃ§in kendi metodumuzu yazmalÄ±yÄ±z ve base `Factory` sÄ±nÄ±fÄ±nÄ±n `state` metodunu kullanmalÄ±yÄ±z:

```php
/**
 * KullanÄ±cÄ±nÄ±n aktif olduÄŸunu belirtir.
 *
 * @return \Illuminate\Database\Eloquent\Factories\Factory
 */
public function active()
{
    return $this->state([
        'status' => 'active',
    ]);
}
```

Daha sonra ÅŸu ÅŸekilde kullanabiliriz:

```php
$users = App\Models\User::factory()->count(10)->active()->make(); // Test amaÃ§lÄ± 10 tane aktif kullanÄ±cÄ± oluÅŸtur.
```

Model factory sÄ±nÄ±flarÄ± iliÅŸkisel verileri de desteklemektedir. Yine yukarÄ±daki Ã¶rnek Ã¼zerinden gidelim. `User` modelinin `Post` modeliyle `hasMany` iliÅŸkisi ve `Post` modelinin `User` modeliyle `belongsTo` iliÅŸkisi olduÄŸunu varsayalÄ±m.

`hasMany` iliÅŸkisi Ã¼zerinden model oluÅŸturmak istiyorsak `has` metodunu kullanabiliriz:

```php
$users = App\Models\User\User::factory()->has(App\Models\Post::factory()->count(10))->create(); // Test amaÃ§lÄ± bir kullanÄ±cÄ± ve bu kullanÄ±cÄ±ya ait 10 tane `Post` oluÅŸtur.

// veya iliÅŸki adÄ±nÄ± Ã¶zelleÅŸtirerek kullanabiliriz (`posts` deÄŸilse):

$users = App\Models\User\User::factory()->has(App\Models\Post::factory()->count(10), 'posts')->create(); // Test amaÃ§lÄ± bir kullanÄ±cÄ± ve bu kullanÄ±cÄ±ya ait 10 tane `Post` oluÅŸtur.

// veya factory'nin magic metodunu kullanabiliriz:

$users = User::factory()->hasPosts(10)->create(); // Test amaÃ§lÄ± bir kullanÄ±cÄ± ve bu kullanÄ±cÄ±ya ait 10 tane `Post` oluÅŸtur.
```

`belongsTo` iliÅŸkisi Ã¼zerinden model oluÅŸturmak istiyorsak da `for` metodunu kullanabiliriz:

```php
$posts = App\Models\Post::factory()->count(10)->for(App\Models\User::factory())->create(); // Test amaÃ§lÄ± bir kullanÄ±cÄ± iÃ§in 10 tane `Post` oluÅŸtur.

// veya iliÅŸki adÄ±nÄ± Ã¶zelleÅŸtirerek kullanabiliriz (`user` deÄŸilse):

$posts = App\Models\Post::factory()->count(10)->for(App\Models\User::factory(), 'user')->create(); // Test amaÃ§lÄ± bir kullanÄ±cÄ± iÃ§in 10 tane `Post` oluÅŸtur.

// veya factory'nin magic metodunu kullanabiliriz:

$posts = App\Models\Post::factory()->count(10)->forUser()->create(); // Test amaÃ§lÄ± bir kullanÄ±cÄ± iÃ§in 10 tane `Post` oluÅŸtur.
```

Burada dikkatli olmamÄ±z gereken bir nokta var; `make` metodu oluÅŸturulan verileri veritabanÄ±na kaydetmezken, `create` metodu Eloquent'in `save` metodunu kullanarak modelleri veritabanÄ±na kaydeder.

Son olarak, eÄŸer factory'leri eski yÃ¶ntemle kullanmaya devam etmek veya upgrade sÃ¼recini kolaylaÅŸtÄ±rmak/hÄ±zlandÄ±rmak istiyorsanÄ±z [`laravel/legacy-factories`](https://github.com/laravel/legacy-factories) paketini kullanabilirsiniz.

<Collapsable title="Kaynak" titleSize="1rem">
    <a href="https://laravel.com/docs/8.x/database-testing" target="_blank">
        Database Testing
    </a>
</Collapsable>

## Migration Squashing

Uzun zamandÄ±r geliÅŸtirdiÄŸimiz projelerde migration dosyalarÄ± gitgide artmaktadÄ±r. VeritabanÄ±nda yaptÄ±ÄŸÄ±mÄ±z her deÄŸiÅŸiklik iÃ§in bir migration dosyasÄ± oluÅŸturuyoruz. Bu da zamanla `database/migrations` klasÃ¶rÃ¼nÃ¼n ÅŸiÅŸmesine neden olacaktÄ±r. Ã–rneÄŸin, Ã§alÄ±ÅŸtÄ±ÄŸÄ±m <a href="https://bulutfiloyonetimi.com/" target="_blank">projede</a> 600'den fazla migration dosyasÄ± var.

EÄŸer MySQL veya PostgreSQL kullanÄ±yorsak, Laravel 8 itibariyle veritabanÄ± ÅŸemamÄ±zÄ± tek bir SQL dosyasÄ±nda tutarak eski migration dosyalarÄ±nÄ± silebiliriz. Bu iÅŸlemi yapmak ÅŸu komutu Ã§alÄ±ÅŸtÄ±rmalÄ±yÄ±z:

```bash
php artisan schema:dump
```

EÄŸer migration dosyalarÄ±nÄ±n da beraberin otomatik olarak silinmesini istiyorsak ÅŸunu Ã§alÄ±ÅŸtÄ±rmamÄ±z yeterli olacaktÄ±r:

```bash
php artisan schema:dump --prune
```

Bu komutu Ã§alÄ±ÅŸtÄ±rdÄ±ktan sonra `database/schema` klasÃ¶rÃ¼nde veritabanÄ± ÅŸema dosyasÄ±nÄ±n oluÅŸtuÄŸunu gÃ¶rebiliriz. Projede yeni migration oluÅŸturarak `migrate` yaptÄ±ÄŸÄ±mÄ±zda Ã¶nce bu SQL dosyasÄ± sonra da yeni oluÅŸturduÄŸumuz migration dosyalarÄ± Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Bu yÃ¶ntemi ara sÄ±ra uygulamakta yarar var. ğŸ˜…

<Info>
    Bu Ã¶zellik sadece MySQL ve PostgreSQL veritabanlarÄ±nda desteklenmektedir.
</Info>
<Collapsable title="Kaynak" titleSize="1rem">
    <a
        href="https://laravel.com/docs/8.x/migrations#squashing-migrations"
        target="_blank"
    >
        Squashing Migrations
    </a>
</Collapsable>

## Job Batching

Job batching Ã¶zelliÄŸi `Bus` facade'Ä± yardÄ±mÄ±yla toplu ÅŸekilde job Ã§alÄ±ÅŸtÄ±rmamÄ±za ve bu sÃ¼reci kolayca yÃ¶netmemize imkÃ¢n saÄŸlÄ±yor. Ã–rneÄŸin, birkaÃ§ job iÅŸlemimiz var ve bu gÃ¶revleri aynÄ± anda Ã§alÄ±ÅŸtÄ±rmak istiyoruz. Hemen aklÄ±mÄ±za ÅŸu sorular takÄ±labilir; _hata Ã§Ä±ktÄ±ÄŸÄ± anda bunu nasÄ±l tespit edebiliriz?_ veya _tÃ¼m iÅŸlemlerin tamamlandÄ±ÄŸÄ±nÄ± nasÄ±l anlarÄ±z?_ Ä°ÅŸte tam bu noktada `then`, `catch` ve `finally` callback'leri imdadÄ±mÄ±za koÅŸuyor.

Bu Ã¶zelliÄŸi kullanmadan Ã¶nce veritabanÄ±nda job bilgilerinin tutulacaÄŸÄ± tabloyu oluÅŸturmamÄ±z gerekiyor. Bunun aÅŸaÄŸÄ±daki komutlarÄ± Ã§alÄ±ÅŸtÄ±rmalÄ±yÄ±z:

```bash
php artisan queue:batches-table
php artisan migrate
```

Daha sonra oluÅŸturacaÄŸÄ±mÄ±z job'lara `Illuminate\Bus\Batchable` traitini eklememiz gerekiyor:

```php
<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

class ProcessPodcast implements ShouldQueue
{
    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Create a new job instance.
     *
     * @return void
     */
    public function __construct()
    {
        //
    }

    /**
     * Execute the job.
     *
     * @return void
     */
    public function handle()
    {
        //
    }
}
```

Daha sonra ÅŸu ÅŸekilde topluca Ã§alÄ±ÅŸtÄ±rabiliriz (dispatch):

```php
use App\Jobs\ProcessPodcast;
use App\Podcast;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Batch;
use Throwable;

$batch = Bus::batch([
    new ProcessPodcast(Podcast::find(1)),
    new ProcessPodcast(Podcast::find(2)),
    new ProcessPodcast(Podcast::find(3)),
    new ProcessPodcast(Podcast::find(4)),
    new ProcessPodcast(Podcast::find(5)),
])->then(function (Batch $batch) {
    // TÃ¼m job iÅŸlemleri baÅŸarÄ±lÄ± bir ÅŸekilde tamamlandÄ±...
})->catch(function (Batch $batch, Throwable $e) {
    // Ä°lk hata tespit edildi...
})->finally(function (Batch $batch) {
    // TÃ¼m job iÅŸlemi tamamlandÄ±...
})->dispatch();

return $batch->id;
```

Laravel Horizon veya Laravel Telescope kullanÄ±yorsanÄ±z, daha kullanÄ±ÅŸlÄ± debug bilgilerini alabilmek iÃ§in Ã§alÄ±ÅŸtÄ±racaÄŸÄ±mÄ±z batch'lere `name` metodunu kullanarak isim verebiliriz:

```php
$batch = Bus::batch([
    // ...
])->then(function (Batch $batch) {
    // TÃ¼m job iÅŸlemleri baÅŸarÄ±lÄ± bir ÅŸekilde tamamlandÄ±...
})->catch(function (Batch $batch, Throwable $e) {
    // Ä°lk hata tespit edildi...
})->finally(function (Batch $batch) {
    // TÃ¼m job iÅŸlemi tamamlandÄ±...
})->name('Process Podcasts')->dispatch(); // highlight-line
```

AynÄ± ÅŸekilde, baÄŸlantÄ± bilgisini `onConnection` ve queue bilgisini de `onQueue` metodunu kullanarak tanÄ±mlayabiliriz:

```php
$batch = Bus::batch([
    // ...
])->then(function (Batch $batch) {
    // TÃ¼m job iÅŸlemleri baÅŸarÄ±lÄ± bir ÅŸekilde tamamlandÄ±...
})->catch(function (Batch $batch, Throwable $e) {
    // Ä°lk hata tespit edildi...
})->finally(function (Batch $batch) {
    // TÃ¼m job iÅŸlemi tamamlandÄ±...
})->onConnection('redis')->onQueue('podcasts')->dispatch(); // highlight-line
```

Burada dikkat etmemiz gerek bir nokta var. `then` tÃ¼m gÃ¶revler **_baÅŸarÄ±lÄ±_** olarak tamamlandÄ±ÄŸÄ±nda, `finally` ise sonuÃ§ baÅŸarÄ±lÄ± veya baÅŸarÄ±sÄ±z farketmeksizin tÃ¼m gÃ¶revler tamamlandÄ±ÄŸÄ±nda Ã§alÄ±ÅŸÄ±r.

Batch ile ilgili bazÄ± kullanÄ±ÅŸlÄ± property ve metodlar:

```php
// Batch'in UUID bilgisi...
$batch->id;

// Batch'in ismi (isimlendirdiyseniz)...
$batch->name;

// Batch'e atanmÄ±ÅŸ job'larÄ±n sayÄ±sÄ±...
$batch->totalJobs;

// Queue tarafÄ±ndan daha Ã§alÄ±ÅŸtÄ±rÄ±lmamÄ±ÅŸ bekleyen job'larÄ±n sayÄ±sÄ±...
$batch->pendingJobs;

// BaÅŸarÄ±sÄ±z sonuÃ§lanan job'larÄ±n sayÄ±sÄ±...
$batch->failedJobs;

// TamamlanmÄ±ÅŸ olan job'larÄ±n sayÄ±sÄ±...
$batch->processedJobs();

// Batch'in tamamlanan yÃ¼zdesi (0-100)...
$batch->progress();

// Batch'in tamamlanÄ±p tamamlanmadÄ±ÄŸÄ±nÄ± belirtir...
$batch->finished();

// Bacth'i iptal eder...
$batch->cancel();

// Batch'in iptal edilip edilmediÄŸini belirtir...
$batch->cancelled();
```

Batch bilgilerinin anlÄ±k olarak JSON Ã§Ä±ktÄ±sÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemek de mÃ¼mkÃ¼n. Bunu yapmak iÃ§in Ã¶rnek bir route oluÅŸturarak `Bus` facade'inin `findBatch` metodundan yararlanabiliriz:

```php:title=app/routes/web.php
use Illuminate\Support\Facades\Bus;
use Illuminate\Support\Facades\Route;

Route::get('/batch/{batchId}', fn (string $batchId) => Bus::findBatch($batchId)); // highlight-line
```

Batch iÃ§indeki herhangi bir job baÅŸarÄ±sÄ±z olduÄŸunda Laravel o job'un _iptal edildiÄŸini_ varsayar. Dilerseniz bu davranÄ±ÅŸÄ± `allowFailures` metodunu kullanarak deÄŸiÅŸtirebilirsiniz:

```php
$batch = Bus::batch([
    // ...
])->then(function (Batch $batch) {
    // TÃ¼m job iÅŸlemleri baÅŸarÄ±lÄ± bir ÅŸekilde tamamlandÄ±...
})->catch(function (Batch $batch, Throwable $e) {
    // Ä°lk hata tespit edildi...
})->finally(function (Batch $batch) {
    // TÃ¼m job iÅŸlemi tamamlandÄ±...
})->allowFailures()->dispatch(); // highlight-line
```

Bunu yaptÄ±ktan sonra job baÅŸarÄ±sÄ±z olduÄŸunda otomatik olarak _iptal_ damgasÄ± yemeyecektir.

BaÅŸarÄ±sÄ±z olan bacth job'larÄ±nÄ± tekrar Ã§alÄ±ÅŸtÄ±rmak isterseniz `queue:retry-batch` komutundan yararlanabilirsiniz:

```bash
php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5 # Batch'in UUID bilgisi
```

<Collapsable title="Kaynak" titleSize="1rem">
    <a href="https://laravel.com/docs/8.x/queues#job-batching" target="_blank">
        Job Batching
    </a>
</Collapsable>

## Rate Limiting GeliÅŸtirmeleri

BildiÄŸiniz gibi daha Ã¶nceleri rate limiting iÃ§in `throttle` middleware API'sini kullanÄ±yorduk. Laravel 8'de daha da geliÅŸtirilen ve esnek hale getirilen rate limiting Ã¶zelliÄŸi iÃ§in `RateLimiter` facade'Ä± tanÄ±tÄ±ldÄ±. Bu facade yardÄ±mÄ±yla artÄ±k Ã¶zel isimlerle rate limiter oluÅŸturabileceÄŸiz. Ama Ã¶nceki sÃ¼rÃ¼mlerle uyumluluÄŸu bozmamak iÃ§in `throttle` middleware API'si de hÃ¢lÃ¢ kullanÄ±labilmekte.

`RouteServiceProvider` iÃ§indeki `configureRateLimiting` metodunda `RateLimiter` facade'Ä±nÄ±n `for` metodunu kullanarak Ã¶zel rate limiter tanÄ±mlayabiliriz:

```php:title=app\Providers\RouteServiceProvider.php
<?php

namespace App\Providers;

use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Foundation\Support\Providers\RouteServiceProvider as ServiceProvider;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
use Illuminate\Support\Facades\Route;

class RouteServiceProvider extends ServiceProvider
{
    // ...

    /**
     * Configure the rate limiters for the application.
     *
     * @return void
     */
    protected function configureRateLimiting()
    {
        RateLimiter::for('api', function (Request $request) {
            return Limit::perMinute(60);
        });

        // highlight-start
        RateLimiter::for('global', function (Request $request) {
            return Limit::perMinute(1000); // Dakika baÅŸÄ± 1000 isteÄŸe kadar izin ver.
        });
        // highlight-end
    }
}
```

Dilerseniz rate limiter'Ä± dinamik olarak tanÄ±mlayabilirsiniz:

```php:title=app\Providers\RouteServiceProvider.php
RateLimiter::for('uploads', function (Request $request) {
    return $request->user()->vipCustomer()
                ? Limit::none()
                : Limit::perMinute(100); // KullanÄ±cÄ± VIP deÄŸilse dakika baÅŸÄ± 100 isteÄŸe kadar izin ver.
});
```

Bazen bazÄ± deÄŸerleri baz alarak rate limiting yapmak isteyebiliriz. Ã–rneÄŸin, her IP adresi baÅŸÄ±na dakikada 60 isteÄŸe kadar izin vermek istiyoruz. Bunu `by` metoduyla yapabiliriz:

```php:title=app\Providers\RouteServiceProvider.php
RateLimiter::for('uploads', function (Request $request) {
    return Limit::perMinute(60)->by($request->ip());  // IP adresi baÅŸÄ±na dakikada 60 isteÄŸe kadar izin ver.
});
```

Hatta bir rate limiter iÃ§inde dizi halinde birkaÃ§ rate limit dÃ¶ndÃ¼rmek mÃ¼mkÃ¼n:

```php
RateLimiter::for('login', function (Request $request) {
    return [
        Limit::perMinute(500), // Dakika baÅŸÄ± 500 isteÄŸe kadar izin ver.
        Limit::perMinute(3)->by($request->input('email')), // E-posta baÅŸÄ± dakikada 3 isteÄŸe kadar izin ver.
    ];
});
```

OluÅŸturduÄŸumuz rate limiter'larÄ± `throttle` middleware yardÄ±mÄ±yla route'lara veya route gruplarÄ±na atayabiliriz:

```php:title=app\routes\web.php
Route::middleware(['throttle:uploads'])->group(function () {
    Route::post('/audio', function () {
        //
    });

    Route::post('/video', function () {
        //
    });
});
```

<Collapsable title="Kaynak" titleSize="1rem">
    <a
        href="https://laravel.com/docs/8.x/routing#rate-limiting"
        target="_blank"
    >
        Rate Limiting
    </a>
</Collapsable>

## BakÄ±m Modu GeliÅŸtirmeleri

`php artisan down` komutuyla aktifleÅŸtirdiÄŸimiz bakÄ±m modunda `allow` seÃ§eneÄŸiyle belirlediÄŸimiz IP adreslerini hariÃ§ bÄ±rakabiliyorduk. Ã–rneÄŸin:

```bash
php artisan down --allow=127.0.0.1
```

Bundan sonra belirlediÄŸimiz token ile `secret` seÃ§eneÄŸini kullanarak da bakÄ±m modundaki uygulamamÄ±za eriÅŸim saÄŸlayabiliriz:

```bash
php artisan down --secret="1630542a-246b-4b66-afa1-dd72a4c43515"
```

Daha sonra uygulamamÄ±zda `https://example.com/1630542a-246b-4b66-afa1-dd72a4c43515` adresini ziyaret etmemiz gerekmekte. Ziyaret sÄ±rasÄ±nda Laravel, bakÄ±m modundayken uygulamamÄ±za eriÅŸebilmemiz iÃ§in tarayÄ±cÄ±mÄ±zda cookie oluÅŸturur. Cookie oluÅŸturulduktan sonra anasayfaya yÃ¶nlendirileceÄŸiz ve artÄ±k normal moddaymÄ±ÅŸ gibi uygulamamÄ±zÄ± kullanabiliriz.

UygulamamÄ±z bakÄ±m modundayken Laravel, varsayÄ±lan olarak 503 status koduyla bakÄ±m sayfasÄ±nÄ± render eder. BakÄ±m sayfasÄ±nÄ± Ã¶zelleÅŸtirmek iÃ§in `resources/views/errors/503.blade.php` dosyasÄ±nÄ± oluÅŸtururak istediÄŸimiz tasarÄ±mÄ± yapabiliriz. Buna alternatif olarak `redirect` seÃ§eneÄŸiyle farklÄ± sayfaya yÃ¶nlendirmemize de imkÃ¢n saÄŸlÄ±yor Laravel:

```bash
php artisan down --redirect=/
```

Son olarak, bakÄ±m modunun _pre-render_ Ã¶zelliÄŸine ve onun Ã¶nemine deÄŸinmek istiyorum. Deployment sÄ±rasÄ±nda uygulamamÄ±zÄ± bakÄ±m moduna aldÄ±ÄŸÄ±mÄ±zÄ± dÃ¼ÅŸÃ¼nelim. Composer paketlerinin veya framework bileÅŸenlerinin tam kurulum/gÃ¼ncelleme esnasÄ±nda uygulamayÄ± ziyaret eden kullanÄ±cÄ±larÄ±n hatayla karÅŸÄ±laÅŸma ihtimali vardÄ±r. Ã‡Ã¼nkÃ¼ uygulamanÄ±n bakÄ±m modunda olup olmadÄ±ÄŸÄ±nÄ± tespit etmek iÃ§in framework'Ã¼n Ã¶nemli bir bÃ¶lÃ¼mÃ¼nÃ¼n yÃ¼klenmesi (boot olmasÄ±) gerekmekte. Bu da gerekli paketlerin ve bileÅŸenlerin tam kurulumundan sonra mÃ¼mkÃ¼n olacaktÄ±r.

Bunu Ã§Ã¶zmek iÃ§in, Laravel bize bakÄ±m sayfasÄ±nÄ± pre-render yapma imkÃ¢nÄ± veriyor. Yani bu Ã¶zellik, request sÃ¼recinin en tepesinde paketler ve framework bileÅŸenleri yÃ¼klenmeden Ã¶nce uygulamanÄ±n bakÄ±m modunda olup olmadÄ±ÄŸÄ±nÄ± tespit ederek bakÄ±m sayfasÄ±nÄ± render etmemizi saÄŸlÄ±yor. `render` seÃ§eneÄŸiyle bakÄ±m sayfasÄ±nÄ± belirtebiliriz:

```bash
php artisan down --render="errors::503"
```

<Collapsable title="Kaynak" titleSize="1rem">
    <a
        href="https://laravel.com/docs/8.x/configuration#maintenance-mode"
        target="_blank"
    >
        Maintenance Mode
    </a>
</Collapsable>

## Closure Dispatch / Chain `catch`

Closure tabanlÄ± job'larÄ±mÄ±z Ã§alÄ±ÅŸÄ±rken (tÃ¼m denemelere raÄŸmen) baÅŸarÄ±sÄ±z olarak sonuÃ§landÄ±ÄŸÄ±nda hatalarÄ± yakalamak iÃ§in `catch` metodundan yararlanabiliriz:

```php
use Throwable;

dispatch(function () use ($podcast) {
    $podcast->publish();
})->catch(function (Throwable $e) {
    // Job baÅŸarÄ±sÄ±z sonuÃ§landÄ±...
});
```

<Collapsable title="Kaynak" titleSize="1rem">
    <a
        href="https://laravel.com/docs/8.x/queues#queueing-closures"
        target="_blank"
    >
        Queueing Closures
    </a>
</Collapsable>

## Dinamik Blade Component'leri

BazÄ± durumlarda dinamik olarak Blade component'i render etmemiz gerekebilir. Bunu Laravel 8'den itibaren built-in olarak gelen `dynamic-component` component'i yardÄ±mÄ±yla yapabiliriz:

```php
<x-dynamic-component :component="$componentName" class="mt-4" />
```

<Collapsable title="Kaynak" titleSize="1rem">
    <a
        href="https://laravel.com/docs/8.x/blade#dynamic-components"
        target="_blank"
    >
        Dynamic Components
    </a>
</Collapsable>

## Event Listener GeliÅŸtirmeleri

Event listener'lar artÄ±k Closure olarak tanÄ±mlanabilmekte. Laravel hangi event'in listen edileceÄŸini tanÄ±mladÄ±ÄŸÄ±mÄ±z Closure sayesinde anlayacaktÄ±r:

```php
use App\Events\PodcastProcessed;
use Illuminate\Support\Facades\Event;

Event::listen(function (PodcastProcessed $event) {
    //
});
```

Ek olarak, bu Closure `Illuminate\Events\queueable` fonksiyonuyla queue olarak da tanÄ±mlanabilir:

```php
use App\Events\PodcastProcessed;
use function Illuminate\Events\queueable;
use Illuminate\Support\Facades\Event;

Event::listen(queueable(function (PodcastProcessed $event) {
    //
}));
```

Queue job'larÄ±nda olduÄŸu gibi `onConnection`, `onQueue` ve `delay` metodlarÄ± da queue listener ile beraber kullanÄ±labilir:

```php
use App\Events\PodcastProcessed;
use function Illuminate\Events\queueable;
use Illuminate\Support\Facades\Event;

Event::listen(queueable(function (PodcastProcessed $event) {
    //
})->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));
```

AyrÄ±ca, olasÄ± hatalarÄ± yakalamk iÃ§in queue listener `catch` metoduyla beraber tanÄ±mlanabilir:

```php
use App\Events\PodcastProcessed;
use function Illuminate\Events\queueable;
use Illuminate\Support\Facades\Event;
use Throwable;

Event::listen(queueable(function (PodcastProcessed $event) {
    //
})->catch(function (PodcastProcessed $event, Throwable $e) {
    // Queued listener baÅŸarÄ±sÄ±z sonuÃ§landÄ±...
}));
```

<Collapsable title="Kaynak" titleSize="1rem">
    <a
        href="https://laravel.com/docs/8.x/events#queuable-anonymous-event-listeners"
        target="_blank"
    >
        Queueable Anonymous Event Listeners
    </a>
</Collapsable>

## Zaman Testi Ä°Ã§in Helper FonksiyonlarÄ±

Test esnasÄ±nda bazen `now` veya `Illuminate\Support\Carbon::now()` gibi zamanla ilgili fonksiyonlardan dÃ¶nen deÄŸerleri deÄŸiÅŸtirmek isteyebiliriz. ArtÄ±k base `Illuminate\Foundation\Testing\TestCase` sÄ±nÄ±fÄ±na dÃ¢hil edilen helper fonksiyonlar sayesinde zamanda yolculuk yapabileceÄŸiz: ğŸ˜…

```php
public function testTimeCanBeManipulated()
{
    // GeleceÄŸe yolculuk...
    $this->travel(5)->milliseconds();
    $this->travel(5)->seconds();
    $this->travel(5)->minutes();
    $this->travel(5)->hours();
    $this->travel(5)->days();
    $this->travel(5)->weeks();
    $this->travel(5)->years();

    // GeÃ§miÅŸe yolculuk...
    $this->travel(-5)->hours();

    // Belirli bir zamana yolculuk...
    $this->travelTo(now()->subHours(6));

    // Åimdiki zamana dÃ¶nÃ¼ÅŸ...
    $this->travelBack();
}
```

<Collapsable title="Kaynak" titleSize="1rem">
    <a
        href="https://laravel.com/docs/8.x/mocking#interacting-with-time"
        target="_blank"
    >
        Interacting With Time
    </a>
</Collapsable>

## Artisan `serve` GeliÅŸtirmeleri

GeliÅŸtirme ortamÄ±nda, `.env` dosyasÄ±nÄ± gÃ¼ncellediÄŸimizde `serve` komutuyla oluÅŸturduÄŸumuz local sunucuyu manuel olarak durdurup tekrar baÅŸlatÄ±yorduk. ArtÄ±k `.env` dosyasÄ± Ã¼zerinde yaptÄ±ÄŸÄ±mÄ±z her gÃ¼ncelleme sonucunda local sunucu otomatik olarak restart olacak.

## Tailwind Ä°le Pagination Linkleri

Daha Ã¶nceleri varsayÄ±lan pagination view'leri <a href="https://getbootstrap.com" target="_blank">Bootstrap</a> ile gelirdi. Laravel 8'den itibaren Bootstrap yerine <a href="https://tailwindcss.com" target="_blank">Tailwind CSS</a> varsayÄ±lan olarak desteklenecek.

Eskisi gibi Bootstrap kullanmaya devam etmek istiyorsanÄ±z, `Paginator` sÄ±nÄ±fÄ±nÄ±n `useBootstrap` metodunu `AppServiceProvider` iÃ§indeki Ã§aÄŸÄ±rmanÄ±z yeterli olacaktÄ±r:

```php:title=app/Providers/AppServiceProvider.php
use Illuminate\Pagination\Paginator;

/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    Paginator::useBootstrap();
}
```

Tailwind CSS ve Bootstrap dÄ±ÅŸÄ±nda <a href="https://semantic-ui.com" target="_blank">Semantic UI</a> da desteklenen framework'ler arasÄ±nda.

<Collapsable title="Kaynak" titleSize="1rem">
    <a
        href="https://laravel.com/docs/8.x/pagination#customizing-the-pagination-view"
        target="_blank"
    >
        Customizing The Pagination View
    </a>
</Collapsable>

## Routing Namespace GÃ¼ncellemeleri

Laravel 8'den Ã¶nce, `RouteServiceProvider` iÃ§inde `$namespace` property'si bulunuyordu. VarsayÄ±lan deÄŸeri `App\Http\Controllers` ÅŸeklindeydi ve bu deÄŸer route tanÄ±mlamalarÄ±mÄ±zda controller sÄ±nÄ±flarÄ±na Ã¶n ek olarak ekleniyordu.

Laravel 8 ile beraber, bu property varsayÄ±lan olarak `RouteServiceProvider` iÃ§inde bulunmuyor, yani varsayÄ±lan deÄŸeri `null` diyebiliriz. ArtÄ±k route tanÄ±mlamalarÄ± ÅŸu ÅŸekilde yapÄ±lacak:

```php:title=app/routes/web.php
use App\Http\Controllers\UserController;

Route::get('/users', [UserController::class, 'index']);
```

`action` tabanlÄ± metodlar da aynÄ± standarta uygun olacak:

```php
use App\Http\Controllers\UserController;

action([UserController::class, 'index']);

return Redirect::action([UserController::class, 'index']);
```

Tabi `RouteServiceProvider` iÃ§inde `$namespace` property'sini tanÄ±mlayarak eski yÃ¶ntemi kullanmaya devam edebilirsiniz.

<Info>

Bu gÃ¼ncelleme sadece <U>yeni</U> Laravel 8 uygulamalarÄ± iÃ§in geÃ§erli olup, eski sÃ¼rÃ¼mden upgrade edilen uygulamalar `$namespace` property'sini kullanmaya devam edecektir.

</Info>

<Collapsable title="Kaynak" titleSize="1rem">
    <a
        href="https://laravel.com/docs/8.x/routing"
        target="_blank"
    >
        Routing
    </a>
</Collapsable>
