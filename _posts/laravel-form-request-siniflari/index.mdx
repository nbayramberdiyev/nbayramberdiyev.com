---
title: Laravel Form Request SÄ±nÄ±flarÄ±
date: 2020-10-18
tags: [laravel, php]
excerpt: Laravel'de form request sÄ±nÄ±flarÄ±nÄ±n etkili kullanÄ±mÄ±
draft: false
---

![](./poster.jpg)

Laravel 5.0 (2015) ile beraber tanÄ±tÄ±lan Ã¶zel form request sÄ±nÄ±flarÄ± Laravel'in nadir kullanÄ±lan ve azÄ±msanan Ã¶zelliklerinden biridir. Sadece authorization ve karmaÅŸÄ±k validation iÅŸlemlerini kolayca yapabilmemizi saÄŸlamak deÄŸil, aslÄ±nda bunlardan daha fazlasÄ±nÄ± yaparak uygulamamÄ±za inanÄ±lmaz faydalar ve kolaylÄ±klar saÄŸlayacak potansiyele sahiptirler.

## Validation

Form request'lerini birÃ§oÄŸumuz validation amaÃ§lÄ± kullanÄ±yoruz. Nitekim Laravel dokÃ¼mantasyonunun <a href="https://laravel.com/docs/master/validation#form-request-validation" target="_blank" rel="nofollow noopener noreferrer">validation bÃ¶lÃ¼mÃ¼nde</a> yer verilmiÅŸ ve ÅŸu ÅŸekilde aÃ§Ä±klanmÄ±ÅŸ:

> Form requests are custom request classes that contain validation logic.

Yani form request'leri validation mantÄ±ÄŸÄ±nÄ±/iÅŸlemlerini iÃ§inde barÄ±ndÄ±ran Ã¶zel request sÄ±nÄ±flarÄ±dÄ±r.

Peki neden validation iÅŸlemlerini controller'da deÄŸil de ayrÄ± bir sÄ±nÄ±fta yapÄ±yoruz? Bunun cevabÄ± kiÅŸiden kiÅŸiye deÄŸiÅŸebilir. Kimileri <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="nofollow noopener noreferrer">Separation of Concerns</a> prensibine uygun kod yazmak ve bÃ¶ylece <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="nofollow noopener noreferrer">Single-responsibility</a> prensibini bozmamak, kimileri de controller metodlarÄ±nÄ±n ÅŸiÅŸmesini engelleyerek daha temiz bir kod yazmak amaÃ§lÄ± kullanmaktadÄ±rlar.

SÃ¶zÃ¼ fazla uzatmadan Ã§ok basit bir Ã¶rnek senaryo Ã¼zerinden validation iÅŸlemlerini etkili ve temiz bir ÅŸekilde nasÄ±l yapÄ±labileceÄŸine bakalÄ±m.

**Ã–rnek:** Blog sitesi yapÄ±yoruz ve `Article` adÄ±nda modelimiz, `ArticleController` adÄ±nda da controller sÄ±nÄ±fÄ±mÄ±z ve bu controller iÃ§inde blog yazÄ±mÄ±zÄ± oluÅŸturmak iÃ§in `store`, gÃ¼ncellemek iÃ§in `update` metodlarÄ±mÄ±z olsun.

```php:title=app/Http/Controllers/ArticleController.php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use Illuminate\Http\Request;

class ArticleController extends Controller
{
    // ...

    public function store(Request $request)
    {
        $data = $request->validate([
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ]);

        $data['is_draft'] ??= false;

        Article::create($data);

        // ...
    }

    public function update(Request $request, Article $article)
    {
        $data = $request->validate([
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ]);

        $data['is_draft'] ??= false;

        $article->update($data);

        // ...
    }

    // ...
}
```

Bu iki metod iÃ§in route tanÄ±mlamalarÄ±mÄ±z ÅŸu ÅŸekilde olsun:

```php:title=app\routes\web.php
<?php

use App\Http\Controllers\ArticleController;
use Illuminate\Support\Facades\Route;

// ...

Route::post('articles', [ArticleController::class, 'store'])->name('articles.store');
Route::put('articles/{article}', [ArticleController::class, 'update'])->name('articles.update');

//...
```
<Info>

Route yapÄ±sÄ±nÄ± ve controller'daki metod isimlendirmelerini bu ÅŸekilde yapmamÄ±n temel nedeni <a href="https://laravel.com/docs/master/controllers#resource-controllers">Resource Controller</a> standartlarÄ±na uymaktÄ±r. MÃ¼mkÃ¼n olduÄŸunca bu yapÄ±ya uygun isimlendirmeler tercih ediyorum.

</Info>

Ve son olarak `Article` modelimizin iÃ§eriÄŸi en basit haliyle ÅŸu ÅŸekilde olsun:

```php:title=app/Models/Article.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    use HasFactory;

    protected $fillable = [
        'title', 'body', 'is_draft',
    ];

    protected $casts = [
        'is_draft' => 'boolean',
    ];

    // ...
}
```

GÃ¶rdÃ¼ÄŸÃ¼nÃ¼z Ã¼zere `articles` tablosunda bizi ilgilendiren sadece 3 alan var: `title`, `body`, `is_draft` (`created_at` ve `updated_at` alanlarÄ±yla ÅŸimdilik bir iÅŸimiz yok).

AsÄ±l konuya gelecek olursak controller'daki `store` ve `update` metodlarÄ±na dikkat ederseniz validation iÅŸlemini yapmak iÃ§in her iki metodda da aynÄ± kodlarÄ± yazdÄ±m. Burada yanlÄ±ÅŸ bir ÅŸey yok ve her ÅŸey olduÄŸu gibi Ã§alÄ±ÅŸacaktÄ±r. Ancak kod tekrarÄ± yaparak <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY (Don't Repeat Yourself)</a> prensibini bozmuÅŸ ve bÃ¶ylece WET (Write Every Time, Write Everything Twice, We Enjoy Typing, Waste Everyone's Time) Ã§Ã¶zÃ¼m Ã¼retmiÅŸ oluyoruz. Daha sonra modele yeni bir alan eklediÄŸimizde veya bir alanÄ± gÃ¼ncellediÄŸimizde her iki yere de yazmak zorunda kalacaÄŸÄ±z. Gelin ÅŸimdi WET kodumuzu DRY yapmaya Ã§alÄ±ÅŸalÄ±m.

### 1. Ä°lk GiriÅŸim

Kodun tekrarlanan (validation) kÄ±smÄ±nÄ± controller iÃ§inde yeni bir metoda yazabiliriz:

```php:title=app/Http/Controllers/ArticleController.php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use Illuminate\Http\Request;

class ArticleController extends Controller
{
    // ...

    public function store(Request $request)
    {
        Article::create($this->validateArticle($request));

        // ...
    }

    public function update(Request $request, Article $article)
    {
        $article->update($this->validateArticle($request));

        // ...
    }

    // highlight-start
    protected function validateArticle(Request $request)
    {
        $article = $request->validate([
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ]);

        $article['is_draft'] ??= false;

        return $article;
    }
    // highlight-end

    // ...
}
```

BÃ¶ylece kod tekrarÄ±ndan kaÃ§Ä±nmÄ±ÅŸ ve en azÄ±ndan DRY prensibini saÄŸlamÄ±ÅŸ olduk. Yine burada da yanlÄ±ÅŸ bir ÅŸey yok, kod Ã§alÄ±ÅŸmasÄ± gerektiÄŸi gibi Ã§alÄ±ÅŸÄ±r.

Peki bunu daha da ileriye gÃ¶tÃ¼rebilir miyiz? Bu Ã§ok basit bir Ã¶rnek, karmaÅŸÄ±k bir validation yapÄ±sÄ±nÄ± hayal edin. Ve nasÄ±l daha da temiz/esnek/sÃ¼rdÃ¼rÃ¼lebilir hale getirebiliriz? "Form request'lerini kullanarak.." dediÄŸinizi duyar gibiyim. Evet, o halde devam edelim ÅŸuradan. ğŸ‘‡

### 2. Ve Form Request Nimetleri ğŸ‰

Form request sÄ±nÄ±flarÄ± validation iÅŸlemlerini yapmak iÃ§in biÃ§ilmiÅŸ kaftandÄ±r. Hatta uygulamamÄ±zÄ±n validation katmanÄ± olarak da dÃ¼ÅŸÃ¼nebiliriz.

Ã–ncelikle `store` metodu iÃ§in `StoreArticleRequest` adÄ±nda bir request sÄ±nÄ±fÄ± oluÅŸturalÄ±m:

```bash
php artisan make:request StoreArticleRequest
```

`app/Http/Requests` klasÃ¶rÃ¼ne baktÄ±ÄŸÄ±mÄ±zda `StoreArticleRequest.php` dosyasÄ±nÄ±n varsayÄ±lan iÃ§eriÄŸinin aÅŸaÄŸÄ±daki gibi sadece 2 metoddan oluÅŸtuÄŸunu gÃ¶rebiliriz:

```php:title=app/Http/Requests/StoreArticleRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreArticleRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return false;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            //
        ];
    }
}
```

#### <U>`authorize` Metodu</U>

OluÅŸturduÄŸumuz form request sÄ±nÄ±fÄ±ndaki `authorize` metodu kullanÄ±cÄ±nÄ±n o isteÄŸi yapÄ±p yapamayacaÄŸÄ±na karar verdiÄŸimiz yer, yani yetki kontrolÃ¼nÃ¼ yaptÄ±ÄŸÄ±mÄ±z metod olarak dÃ¼ÅŸÃ¼nebiliriz. BildiÄŸiniz gibi, Laravel'de authorization iÅŸlemlerini farklÄ± yerlerde Ã§eÅŸitli yÃ¶ntemlerle harici bir paket kullanarak veya kullanmayarak yapabiliyoruz. Bunlardan biri de form request'lerindeki `authorize` metodu. EÄŸer baÅŸka yerde yetki kontrolÃ¼ yapÄ±yorsak burada `true` dÃ¶ndÃ¼rebiliriz, bunda hiÃ§bir sakÄ±nca yok.

#### <U>`rules` Metodu</U>

`rules` metodu formdan gelecek veriler iÃ§in validation kurallarÄ±nÄ± tanÄ±mladÄ±ÄŸÄ±mÄ±z yer. KÄ±sacasÄ±, `store` metodundaki validation kurallarÄ±nÄ± buraya taÅŸÄ±dÄ±ÄŸÄ±mÄ±zda `StoreArticleRequest` sÄ±nÄ±fÄ±nÄ±n iÃ§eriÄŸi ÅŸu ÅŸekilde olacak:

```php:title=app/Http/Requests/StoreArticleRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreArticleRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ];
    }
}
```

Burada `is_draft` alanÄ± view tarafÄ±nda checkbox (tipi ise `boolean`) olduÄŸu iÃ§in eÄŸer checkbox seÃ§ilmemiÅŸse `is_draft` alanÄ±nÄ±n deÄŸeri gelmeyecektir. Bu yÃ¼zden varsayÄ±lan bir deÄŸer atamak zorundayÄ±z. Bunu veritabanÄ± tarafÄ±nda da yapabileceÄŸimiz gibi form request sÄ±nÄ±fÄ± iÃ§inde `prepareForValidation` metodunu tanÄ±mlayarak da kolayca yapabiliyoruz.

#### <U>`prepareForValidation` Metodu</U>

`prepareForValidation` metodu adÄ±ndan da anlaÅŸÄ±lacaÄŸÄ± Ã¼zere validation iÅŸleminden Ã¶nce verilerimizi manipÃ¼le etmemizi saÄŸlamaktadÄ±r. Verilerimizi validation iÃ§in hazÄ±ladÄ±ÄŸÄ±mÄ±z yer olarak dÃ¼ÅŸÃ¼nebiliriz. Ã–rneÄŸin, bir alana varsayÄ±lan veya koÅŸullu deÄŸer atama, deÄŸerini deÄŸiÅŸtirme, (<a href="https://www.php.net/manual/en/function.trim.php" target="_blank" rel="nofollow noopener noreferrer">`trim`</a> veya <a href="https://www.php.net/manual/en/function.addslashes.php" target="_blank" rel="nofollow noopener noreferrer">`addslashes`</a> gibi) sanitize iÅŸlemlerini yapma, vb.

`is_draft` alanÄ± iÃ§in `prepareForValidation` metodunu override ederek varsayÄ±lan deÄŸer atayabileceÄŸimizi belirtmiÅŸtim. KullanÄ±cÄ±nÄ±n `is_draft` alanÄ±nÄ± iÅŸaretlemediÄŸi durumlarda varsayÄ±lan olarak `false` deÄŸerini atamamÄ±z gerekiyor:

```php:title=app/Http/Requests/StoreArticleRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreArticleRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ];
    }

    // highlight-start
    protected function prepareForValidation()
    {
        $this->merge([
            'is_draft' => $this->input('is_draft', false),
        ]);
    }
    // highlight-end
}
```

BÃ¶ylece eÄŸer `is_draft` checkbox alanÄ± seÃ§ilmemiÅŸse `false` deÄŸerini, seÃ§ilmiÅŸse de `boolean` olduÄŸu iÃ§in 1, '1' veya `true` deÄŸerini atayarak validation iÅŸlemine hazÄ±rlamÄ±ÅŸ olduk.

Verilerimizi ve kurallarÄ±mÄ±zÄ± validation iÃ§in hazÄ±rladÄ±ktan sonra bir de validation sonrasÄ±nÄ± dÃ¼ÅŸÃ¼nmemiz gerekiyor. Ã–rneÄŸin, hata mesajlarÄ±. BildiÄŸiniz gibi validation iÅŸlemi baÅŸarÄ±sÄ±z olduÄŸunda request controller metoduna girmeden (hata mesajlarÄ±yla birlikte) geldiÄŸi yere geri gÃ¶nderilir. ğŸ˜… AJAX isteÄŸi gelidyse de 422 status koduyla hata mesajlarÄ±nÄ±n JSON Ã§Ä±ktÄ±sÄ± dÃ¶ndÃ¼rÃ¼lÃ¼r.

Peki bu hata mesajlarÄ±nÄ± nasÄ±l Ã¶zelleÅŸtirebiliriz? VarsayÄ±lan mesajlar nelerdir ve nerede tutulurlar?

#### <U>`messages` Metodu</U>

Validation hatalarÄ± iÃ§in varsayÄ±lan olarak `resources/lang/x/validation.php` iÃ§indeki belirlenen mesajlar kullanÄ±lÄ±r. Bu dosyadan hem global hem de belirli alanlarÄ±n hata mesajlarÄ±nÄ± Ã¶zelleÅŸtirebileceÄŸimiz gibi aynÄ± zamanda form request sÄ±nÄ±fÄ± iÃ§indeki `messages` metodunu override ederek de yapabiliyoruz:

```php:title=app/Http/Requests/StoreArticleRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreArticleRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ];
    }

    protected function prepareForValidation()
    {
        $this->merge([
            'is_draft' => $this->input('is_draft', false),
        ]);
    }

    // highlight-start
    public function messages()
    {
        return [
            'title.required'   => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'title.between'    => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'body.required'    => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'body.between'     => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'is_draft.boolean' => ':attribute deÄŸeri geÃ§erli deÄŸil.',
        ];
    }
    // highlight-end
}
```

Burada dikkatli olmamÄ±z gereken bir nokta var. Hata mesajlarÄ±ndaki `:attribute` kÄ±smÄ± alanlarÄ±n ismine (formdaki input/select/textarea alanÄ±nÄ±n `name` deÄŸerine) karÅŸÄ±lÄ±k gelir. DolayÄ±sÄ±yla yukarÄ±daki mesajlarÄ±n ilk 2 satÄ±rÄ±na `title`, sonraki 2 satÄ±rÄ±na `body` ve son satÄ±ra `is draft` basÄ±lÄ±r. Ã–rneÄŸin, `title` alanÄ±nÄ± boÅŸ bÄ±raktÄ±ÄŸÄ±mÄ±zda _"title boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r."_ hata mesajÄ±nÄ± alÄ±rÄ±z. Bu da bizim iÃ§in kullanÄ±ÅŸlÄ± olmayacaktÄ±r.

Bunu `resources/lang/x/validation.php` iÃ§indeki `attributes` kÄ±smÄ±nda Ã¶zel isimler tanÄ±mlayarak Ã§Ã¶zebileceÄŸimiz gibi aynÄ± zamanda form request'in bir diÄŸer nimeti olan `attributes` metodunu override ederek de Ã§Ã¶zÃ¼m Ã¼retebiliriz.

#### <U>`attributes` Metodu</U>

`attributes` metodu hata mesajlarÄ±ndaki `:attribute` kÄ±smÄ±nÄ±, yani formdaki elemanlarÄ±n adÄ±nÄ± Ã¶zelleÅŸtirebilmemize olanak saÄŸlar:

```php:title=app/Http/Requests/StoreArticleRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreArticleRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ];
    }

    protected function prepareForValidation()
    {
        $this->merge([
            'is_draft' => $this->input('is_draft', false),
        ]);
    }

    public function messages()
    {
        return [
            'title.required'   => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'title.between'    => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'body.required'    => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'body.between'     => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'is_draft.boolean' => ':attribute deÄŸeri geÃ§erli deÄŸil.',
        ];
    }

    // highlight-start
    public function attributes()
    {
        return [
            'title'    => 'BaÅŸlÄ±k',
            'body'     => 'Ä°Ã§erik',
            'is_draft' => 'Taslak',
        ];
    }
    // highlight-end
}
```

#### <U>`withValidator` Metodu</U>

Validation iÅŸleminin hemen sonrasÄ±nda Ã¶zel olarak bazÄ± deÄŸerleri kontrol etmemiz veya Ã¶zel validation iÅŸemini gerÃ§ekleÅŸtirmemiz gerekebilir. Veya tamamen baÅŸka fonksiyon(lar) Ã§alÄ±ÅŸtÄ±rma ihtiyacÄ±mÄ±z da olabilir. Ä°ÅŸte tam bu noktada `withValidator` metodu, namÄ±diÄŸer "after" hook, devreye giriyor.

Ã–rnek senaryomuzda ihtiyacÄ±mÄ±z olmadÄ±ÄŸÄ± iÃ§in kullanmayacaÄŸÄ±z ama baÅŸlÄ±kta "tiktok" veya "tik tok" kelimesininin kullanÄ±lmasÄ±nÄ± engellemek istediÄŸimizi dÃ¼ÅŸÃ¼nÃ¼rsek `withValidator` metodundan ÅŸu ÅŸekilde yararlanabiliriz:

```php
public function withValidator($validator)
{
    $validator->after(function ($validator) {
        if (mb_stripos($this->title, 'tiktok') !== false || mb_stripos($this->title, 'tik tok') !== false) {
            $validator->errors()->add('title', 'BaÅŸlÄ±kta "tiktok" veya "tik tok" kelimesi kullanÄ±lmamlÄ±.');
        }
    });
}
```

EÄŸer buradaki validation iÅŸlemi daha karmaÅŸÄ±k veya (baÅŸka yerlerde de kullanabileceÄŸiniz) kalÄ±cÄ± bir kural olacaksa Ã¶zel validation kuralÄ± oluÅŸturmanÄ±z daha doÄŸru olur.

EÄŸer ("after" hook dÃ¢hil) validation iÅŸlemi baÅŸarÄ±sÄ±z olursa request daha controller iÃ§ine girmeden hata mesajlarÄ±yla beraber geri gÃ¶nderilir demiÅŸtik. Genelde yeni kayÄ±t sayfasÄ±ndan form gÃ¶nderildiÄŸi iÃ§in oraya geri gÃ¶nderilerek hata mesajlarÄ± ilgili yerlere basÄ±lÄ±r. Peki geri gÃ¶nderilmesini deÄŸil, baÅŸka bir yere gÃ¶nderilmesini istiyorsak ne yapacaÄŸÄ±z? Ã–zel URL tanÄ±mlayamÄ±yor muyuz?

#### <U>`getRedirectUrl` Metodu</U>

Validation baÅŸarÄ±sÄ±z sonuÃ§landÄ±ÄŸÄ±nda geriye deÄŸil Ã¶zel URL adresine redirect yapmak istiyorsak `getRedirectUrl` metodunu override edebiliriz:

```php
public function getRedirectUrl()
{
    return route('articles.index');

    // veya

    return '/articles';
}
```

Bu metoda da ihtiyacÄ±mÄ±z olmadÄ±ÄŸÄ±ndan Ã¶rneÄŸimize dÃ¢hil etmedim.

Peki yÃ¶nlendirmeden Ã¶nce Ã¶zel iÅŸlemler yapmak istiyorsak ne olacak? Ã–rneÄŸin, hatalarÄ± loglara kaydetmek ve daha sonra yÃ¶nlendirme yapmak istiyoruz. Bunun iÃ§in de bir metod var mÄ±?

#### <U>`failedValidation` Metodu</U>

Validation iÅŸlemi baÅŸarÄ±sÄ±z olduÄŸunda normalde `Illuminate\Validation\ValidationException` hatasÄ± fÄ±rlatÄ±larak hata mesajlarÄ±yla beraber geri redirect uygulanÄ±r. Bu standart ve doÄŸru bir yÃ¶ntem olmasÄ±na raÄŸmen bazen baÅŸka iÅŸlemler yapmak isteyebiliriz. Yani redirect olmadan Ã¶nce birkaÃ§ iÅŸleme ihtiyacÄ±mÄ±z olabilir. Veya Ã¶zel tanÄ±mladÄ±ÄŸÄ±mÄ±z hatalarÄ± fÄ±rlatmak isteyebiliriz. Bunun iÃ§in `failedValidation` metodunu override edebiliriz:

```php:title=app/Http/Requests/StoreArticleRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Contracts\Validation\Validator;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Facades\Log;

class StoreArticleRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ];
    }

    protected function prepareForValidation()
    {
        $this->merge([
            'is_draft' => $this->input('is_draft', false),
        ]);
    }

    public function messages()
    {
        return [
            'title.required'   => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'title.between'    => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'body.required'    => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'body.between'     => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'is_draft.boolean' => ':attribute deÄŸeri geÃ§erli deÄŸil.',
        ];
    }

    public function attributes()
    {
        return [
            'title'    => 'BaÅŸlÄ±k',
            'body'     => 'Ä°Ã§erik',
            'is_draft' => 'Taslak',
        ];
    }

    // highlight-start
    protected function failedValidation(Validator $validator)
    {
        // Validation hatalarÄ±nÄ± loglara yaz.
        Log::debug(json_encode($validator->errors(), JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE));

        // Sonra normal akÄ±ÅŸa devam et.
        parent::failedValidation($validator);
    }
    // highlight-end
}
```

Bunun tam tersini de yapabiliriz. Yani validation baÅŸarÄ±lÄ± olduÄŸunda istediÄŸimiz iÅŸlemleri `passedValidation` metodu yardÄ±mÄ±yla yapabiliriz.

#### <U>`passedValidation` Metodu</U>

Validation iÅŸlemi baÅŸarÄ±lÄ± olduÄŸunda tetiklenecek olan metoddur.

```php:title=app/Http/Requests/StoreArticleRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Contracts\Validation\Validator;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Facades\Log;

class StoreArticleRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ];
    }

    protected function prepareForValidation()
    {
        $this->merge([
            'is_draft' => $this->input('is_draft', false),
        ]);
    }

    public function messages()
    {
        return [
            'title.required'   => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'title.between'    => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'body.required'    => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'body.between'     => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'is_draft.boolean' => ':attribute deÄŸeri geÃ§erli deÄŸil.',
        ];
    }

    public function attributes()
    {
        return [
            'title'    => 'BaÅŸlÄ±k',
            'body'     => 'Ä°Ã§erik',
            'is_draft' => 'Taslak',
        ];
    }

    protected function failedValidation(Validator $validator)
    {
        // Validation hatalarÄ±nÄ± loglara yaz.
        Log::debug(json_encode($validator->errors(), JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE));

        // Sonra normal akÄ±ÅŸa devam et.
        parent::failedValidation($validator);
    }

    // highlight-start
    protected function passedValidation()
    {
        //
    }
    // highlight-end
}
```

Peki validation deÄŸil de _authorization_ iÅŸlemi baÅŸarÄ±sÄ±z olduÄŸunda bazÄ± iÅŸlemler yapmak istiyorsak? Daha Ã¶nce form request sÄ±nÄ±flarÄ±nda `authorize` metodunu kullanarak authorization iÅŸlemini yapabileceÄŸimizden bahsetmiÅŸtik. EÄŸer authorization baÅŸarÄ±sÄ±z olursa istediÄŸimiz iÅŸlemleri nasÄ±l yaparÄ±z?

#### <U>`failedAuthorization` Metodu</U>

Authorization iÅŸlemi baÅŸarÄ±sÄ±z olduÄŸunda normalde 403 status koduyla `Illuminate\Auth\Access\AuthorizationException` hatasÄ± fÄ±rlatÄ±lÄ±r. Bu varsayÄ±lan davranÄ±ÅŸÄ± `failedAuthorization` metodunu override ederek deÄŸiÅŸtirebiliriz. Ãœstteki Ã¶rnek gibi, authorization iÅŸleminin baÅŸarÄ±sÄ±z olduÄŸuna ve hangi request iÃ§inde gerÃ§ekleÅŸtiÄŸine dair log kayÄ±tlarÄ±nÄ± tutmak istiyorsak ÅŸu ÅŸekilde yapabiliriz:

```php:title=app/Http/Requests/StoreArticleRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Contracts\Validation\Validator;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Facades\Log;

class StoreArticleRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'title'     => ['required', 'between:5,255'],
            'body'      => ['required', 'between:50,5000'],
            'is_draft'  => ['boolean'],
        ];
    }

    protected function prepareForValidation()
    {
        $this->merge([
            'is_draft' => $this->input('is_draft', false),
        ]);
    }

    public function messages()
    {
        return [
            'title.required'   => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'title.between'    => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'body.required'    => ':attribute boÅŸ bÄ±rakÄ±lmamalÄ±dÄ±r.',
            'body.between'     => ':attribute :min ile :max karakter arasÄ± olmalÄ±dÄ±r.',
            'is_draft.boolean' => ':attribute deÄŸeri geÃ§erli deÄŸil.',
        ];
    }

    public function attributes()
    {
        return [
            'title'    => 'BaÅŸlÄ±k',
            'body'     => 'Ä°Ã§erik',
            'is_draft' => 'Taslak',
        ];
    }

    protected function failedValidation(Validator $validator)
    {
        // Validation hatalarÄ±nÄ± loglara yaz.
        Log::debug(json_encode($validator->errors(), JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE));

        // Sonra normal akÄ±ÅŸa devam et.
        parent::failedValidation($validator);
    }

    protected function passedValidation()
    {
        //
    }

    // highlight-start
    protected function failedAuthorization()
    {
        // Authorization iÅŸleminin baÅŸarÄ±sÄ±z olduÄŸunu ve nerede gerÃ§ekleÅŸtiÄŸini loglara yaz.
        Log::debug(__CLASS__.': Authorization baÅŸarÄ±sÄ±z.');

        // Sonra normal akÄ±ÅŸa devam et.
        parent::failedAuthorization();
    }
    // highlight-end
}
```

#### <U>`passesAuthorization` Metodu</U>

Validation kÄ±smÄ± iÃ§in son olarak `passesAuthorization` metodundan bahsetmek istiyorum. Daha Ã¶nce hiÃ§ kullanmadÄ±m, nerede ve ne zaman ihtiyacÄ±mÄ±z olur bir fikrim yok ama sakÄ±n ola `authorize` metodu iÃ§inde kullanmayÄ±n. ğŸ˜…

`passesAuthorization` metodu request'in authorization iÅŸleminden baÅŸarÄ±lÄ± ÅŸekilde geÃ§ip geÃ§mediÄŸini tespit etmemizi saÄŸlÄ±yor. Bunun iÃ§in form request sÄ±nÄ±fÄ±ndaki `authorize` metodunu Ã§alÄ±ÅŸtÄ±rarak sonucunu dÃ¶ndÃ¼rÃ¼r.

```php
if ($this->passesAuthorization()) {
    // `authorize` metodu `true` dÃ¶ndÃ¼rdÃ¼.
}
```

#### <U>Controller Ä°Ã§inde KullanÄ±mÄ±</U>

Ã–zel request sÄ±nÄ±fÄ±nÄ± yazdÄ±ktan sonra controller'Ä±n `store` metodu iÃ§inde varsayÄ±lan `Illuminate\Http\Request` sÄ±nÄ±fÄ± yerine `App\Http\Requests\StoreArticleRequest` sÄ±nÄ±fÄ±nÄ± kullanalÄ±m:

```php:title=app/Http/Controllers/ArticleController.php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\StoreArticleRequest;
use App\Models\Article;
use Illuminate\Http\Request;

class ArticleController extends Controller
{
    // ...

    public function store(StoreArticleRequest $request)
    {
        Article::create($request->validated());

        // ...
    }

    // ...
}
```

Formdan gelecek olan veriler `StoreArticleRequest` iÃ§inde tanÄ±mlanan validation kurallarÄ±nÄ± baÅŸarÄ±lÄ± ÅŸekilde geÃ§tiÄŸi taktirde `store` metodu tetiklenecek ve `validated` metodunu kullanarak validation sÃ¼zgecinden geÃ§en verilerimizi alabileceÄŸiz.

GÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi `store` metodunu bir hayli temizledik ve controller sÄ±nÄ±fÄ±nÄ± validation iÅŸlemlerinden kurtardÄ±k. Peki blog yazÄ±mÄ±zÄ± gÃ¼ncellediÄŸimiz `update` metodunda da bu request sÄ±nÄ±fÄ±nÄ± kullanabilir miyiz? EÄŸer aynÄ± validation kurallarÄ±na ve aynÄ± iÅŸlemlere ihtiyacÄ±mÄ±z varsa rahatlÄ±kla kullanabiliriz. Hatta ufak farklÄ±lÄ±klar varsa ve zamanla karmaÅŸÄ±k/farklÄ± bir yapÄ±ya dÃ¶nÃ¼ÅŸmeyeceÄŸinden emin isek 2 request'i birleÅŸtirebiliriz. Ã–rneÄŸin, validation kurallarÄ±nÄ±n farklÄ±lÄ±k gÃ¶sterdiÄŸini ve bunlarÄ± birleÅŸtirme istediÄŸimi dÃ¼ÅŸÃ¼nÃ¼rsek ÅŸuna benzer bir yapÄ± oluÅŸturabiliriz:

```php
protected function storeRules()
{
    return [
        'title'     => ['required', 'between:5,255'],
        'slug'      => ['required', 'between:5,255', 'unique:articles,slug'],
        'body'      => ['required', 'between:5,5000'],
        'is_draft'  => ['boolean'],
    ];
}

protected function updateRules()
{
    return [
        'title'     => ['required', 'between:5,255'],
        'body'      => ['required', 'between:5,5000'],
        'is_draft'  => ['boolean'],
    ];
}

public function rules()
{
    return $this->isMethod('POST') ? $this->storeRules() : $this->updateRules();
}
```

<Info>

Bu ÅŸekilde request sÄ±nÄ±flarÄ±nÄ± birleÅŸtirerek birkaÃ§ yerde kullanmak istediÄŸimizde karÄ±ÅŸÄ±klÄ±k yaratmamasÄ± iÃ§in request sÄ±nÄ±fÄ±nÄ±
`StoreArticleRequest` deÄŸil, `ArticleRequest` olarak isimlendirmenizde yarar var. Ã‡Ã¼nkÃ¼ isimdeki Ã¶n ek (`Store`) request'in kullanÄ±lacaÄŸÄ± controller metodunun ismine denk gelmektedir.

</Info>

SonuÃ§ olarak bir validation sÃ¼reci iÃ§in ihtiyacÄ±mÄ±z olabilecek tÃ¼m iÅŸlemleri gÃ¶rdÃ¼k. Peki form request sÄ±nÄ±flarÄ±yla daha fazla neler yapabÄ±labilir?

## Validation Ã–tesi

Bazen mevcut request'e Ã¶zel iÅŸlemler yapmaya ihtiyaÃ§ duyabiliriz. Veya mevcut request iÃ§inde gelen form verilerini kullanarak Ã¶zel kontrol yapÄ±larÄ± oluÅŸturmak isteriz. Ã–rneÄŸin, kiÅŸisel projelerimin birinde ÅŸÃ¶yle bir form request sÄ±nÄ±fÄ± var:

```php:title=app/Http/Controllers/UpgradeSubscriptionRequest.php
<?php

namespace App\Http\Requests;

use App\Enums\Plan;
use BenSampo\Enum\Rules\EnumValue;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Facades\DB;

class UpgradeSubscriptionRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            'plan' => ['required', 'integer', 'min:2', new EnumValue(Plan::class, false)],
        ];
    }

    /**
     * KullanÄ±cÄ±nÄ±n yÃ¼kseltmek istediÄŸi paket mevcut paketinden yÃ¼ksek olup olmadÄ±ÄŸÄ±nÄ± kontrol et.
     *
     * @return bool
     */
    public function userCanUpgradePlan()
    {
        return $this->user()->plan < $this->plan;
    }

    /**
     * KullanÄ±cÄ±nÄ±n zaten bir baÅŸvurusunun olup olmadÄ±ÄŸÄ±nÄ± kontrol et.
     *
     * @return bool
     */
    public function userAlreadyApplied()
    {
        return DB::table('upgrade_applications')->where('user_id', $this->user()->id)->exists();
    }
}
```

Bu request sÄ±nÄ±fÄ± kullanÄ±cÄ±nÄ±n Ã¼yelik yÃ¼kseltme baÅŸvurusu yaptÄ±ÄŸÄ± sÄ±rada kullanÄ±lmaktadÄ±r. Validation iÅŸlemine ek olarak 2 tane kontrol yapÄ±sÄ±nÄ± oluÅŸturan metod yazdÄ±m. KullanÄ±cÄ±nÄ±n yÃ¼kseltmek istediÄŸi paket mevcut paketinden yÃ¼ksek olmak zorunda. Bunu `userCanUpgradePlan` metodu ile kontrol ediyorum. Ve kullanÄ±cÄ±nÄ±n (devam eden) mevcut baÅŸvurusu varsa tekrar baÅŸvuru yapmasÄ±na gerek yok. Bunu da `userAlreadyApplied` metodu ile tespit ediyorum.

EÄŸer burada kullanÄ±cÄ±nÄ±n yÃ¼kseltmek istediÄŸi paket mevcut paketinden yÃ¼ksek ise ve devam eden baÅŸvurusu yok ise o kullanÄ±cÄ± iÃ§in yeni bir baÅŸvuru oluÅŸturulur ve paket, Ã¶deme yÃ¶ntemi vs. ile ilgili bilgiler kullanÄ±cÄ±ya e-posta ile gÃ¶nderilir.

Tabi ki bunlar UI tarafÄ±nda da kontrol edilmekte ve Ã¼yelik yÃ¼kseltme sayfasÄ±nda kullanÄ±cÄ±nÄ±n sadece mevcut paketinden yÃ¼ksek olan paketler listelenmektedir. Ama kullanÄ±cÄ±nÄ±n form verilerini manipÃ¼le edebileceÄŸini aklÄ±mÄ±zdan Ã§Ä±karmamalÄ±yÄ±z.

Peki bu metodlarÄ± controller iÃ§inde yazamaz mÄ±ydÄ±m? Yazabilirdim elbette ama request verileriyle ilgili kontrol yapÄ±larÄ±nÄ± form request sÄ±nÄ±fÄ± iÃ§inde yapmayÄ± mantÄ±klÄ± buluyorum. Ã‡Ã¼nkÃ¼ hem mevcut request'e Ã¶zel verileri hem de o request'i yapan kullanÄ±cÄ± bilgisini kullanarak karar mekanizmasÄ± oluÅŸturdum ve bÃ¶ylece **mevcut request iÃ§indeki bir ÅŸeyleri Ã§Ã¶zmÃ¼ÅŸ oldum**. Bu aÃ§Ä±dan baktÄ±ÄŸÄ±mÄ±zda controller'dan ziyade form request sÄ±nÄ±fÄ±nÄ±n bu tarz iÅŸlemler iÃ§in daha uygun olduÄŸunu gÃ¶rebiliriz.
